import { Injectable, Inject } from '@nestjs/common';
import { ICertificateRepository } from '@/domain/repositories/certificate.repository.interface';
import { Certificate } from '@/domain/models/certificate.model';
import { Status } from '@/domain/value-objects';
import { CreateCertificateDto } from './create-certificate.dto';
import { AdminCertificateResponseDto } from '../../queries/admin/get-certificate/admin-certificate.response.dto';
import { ValidationException } from '@/domain/exceptions';

/**
 * Create Certificate Use Case
 * Handles the business logic for creating a new certificate
 */
@Injectable()
export class CreateCertificateUseCase {
    constructor(
        @Inject('ICertificateRepository')
        private readonly certificateRepo: ICertificateRepository,
    ) { }

    async execute(dto: CreateCertificateDto): Promise<AdminCertificateResponseDto> {
        // 1. Validate certificate number uniqueness if provided
        if (dto.certificateNumber) {
            const exists = await this.certificateRepo.existsByCertificateNumber(dto.certificateNumber);
            if (exists) {
                throw new ValidationException(`Certificate number ${dto.certificateNumber} already exists`);
            }
        }

        // 2. Create domain entity
        const certificate = Certificate.create(0n, {
            // ID will be generated by DB
            name: dto.name,
            image: dto.image,
            issuedBy: dto.issuedBy,
            issuedDate: dto.issuedDate ? new Date(dto.issuedDate) : undefined,
            expiryDate: dto.expiryDate ? new Date(dto.expiryDate) : undefined,
            certificateNumber: dto.certificateNumber,
            description: dto.description,
            type: dto.type,
            status: Status.fromString(dto.status || 'active'),
            sortOrder: dto.sortOrder || 0,
            createdAt: new Date(),
            updatedAt: new Date(),
        });

        // 3. Save to repository
        const saved = await this.certificateRepo.save(certificate);

        // 4. Return DTO
        return AdminCertificateResponseDto.fromDomain(saved);
    }
}
